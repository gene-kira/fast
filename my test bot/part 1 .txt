# === Autoloader for Required Libraries ===
import importlib, subprocess, sys

def autoload(packages):
    for pkg in packages:
        try:
            importlib.import_module(pkg)
        except ImportError:
            subprocess.check_call([sys.executable, "-m", "pip", "install", pkg])

autoload(["tkinter", "json", "requests", "operator", "random", "pyttsx3"])

# === Imports ===
import tkinter as tk
from tkinter import filedialog, scrolledtext
import operator, random, json, requests, webbrowser
import pyttsx3

# === Voice Engine ===
def speak(text, volume_percent):
    try:
        engine = pyttsx3.init()
        engine.setProperty("volume", max(0.0, min(1.0, volume_percent / 100)))
        engine.say(text)
        engine.runAndWait()
    except Exception as e:
        print(f"[Voice Error]: {e}")

# === Memory Kernel ===
class MemoryKernel:
    def __init__(self, file="glyph_memory.json"):
        self.file = file
        try:
            with open(file, "r") as f:
                self.data = json.load(f)
        except:
            self.data = []

    def store(self, input_text, result, glyphs, trace=None):
        entry = {
            "input": input_text,
            "result": result,
            "glyphs": glyphs,
            "trace": trace or "Initial deduction"
        }
        self.data.append(entry)
        with open(self.file, "w") as f:
            json.dump(self.data, f, indent=2)

    def get_lineage(self, current_input):
        for entry in reversed(self.data):
            if entry["input"] != current_input and entry["glyphs"]:
                return f"Building on earlier deduction: {entry['input']} ‚Üí {entry['result']}"
        return None

    def dump(self):
        return "\n".join([f"{e['input']} ‚Üí {e['result']} {e['glyphs']}, Trace: {e['trace']}" for e in self.data])

# === Glyph Encoder ===
def encode_glyph(text):
    glyphs = []
    if any(op in text for op in ["+", "-", "*", "/"]):
        glyphs.append("üßÆ")
    if any(op in text for op in ["¬¨", "‚Üí", "‚àß", "‚à®", "not", "implies", "and", "or"]):
        glyphs.append("üî£")
    if "(" in text or ")" in text:
        glyphs.append("‚äï")
    if "web:" in text:
        glyphs.append("üåê")
    glyphs.append("üîê")
    return glyphs

# === Symbolic Parser ===
def parse_symbolic(expr):
    return expr.replace("¬¨", "not ").replace("‚Üí", "implies ").replace("‚àß", "and ").replace("‚à®", "or ")

# === Web Search Logic ===
def web_trace(query):
    try:
        url = f"https://www.bing.com/search?q={query.replace(' ', '+')}"
        webbrowser.open(url)
        return f"web:{url}"
    except:
        return "web:error"

# === Reverse Reasoning Core ===
NUMERIC_OPS = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv
}

LOGIC_OPS = {
    'AND': lambda a, b: a and b,
    'OR': lambda a, b: a or b,
    'IMPLIES': lambda a, b: not a or b,
    'EQUIV': lambda a, b: a == b
}

def numeric_reverse(target, tries=300):
    results = []
    for _ in range(tries):
        a = random.randint(0, target * 2)
        b = random.randint(1, target * 2)
        for sym, func in NUMERIC_OPS.items():
            try:
                if round(func(a, b), 4) == round(target, 4):
                    results.append(f"{a} {sym} {b}")
            except ZeroDivisionError:
                continue
    return sorted(set(results))

def logic_reverse(target, tries=200):
    values = [True, False]
    results = []
    for _ in range(tries):
        a, b = random.choice(values), random.choice(values)
        for sym, func in LOGIC_OPS.items():
            if func(a, b) == target:
                results.append(f"{a} {sym} {b}")
    return sorted(set(results))

